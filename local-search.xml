<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>第二章-线性表</title>
    <link href="/2021/04/23/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <url>/2021/04/23/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="考纲内容"><a href="#考纲内容" class="headerlink" title="考纲内容"></a>考纲内容</h1><p>（一）线性表的定义和操作</p><p>（二）线性表的实现</p><p>​        顺序存储；链式存储；线性表的应用</p><h1 id="知识框架"><a href="#知识框架" class="headerlink" title="知识框架"></a>知识框架</h1><p><img src="https://gitee.com/zxyss/blogimg/raw/master/img/20210423180651.jpg" alt=""></p><h3 id="2-1-1-线性表的定义"><a href="#2-1-1-线性表的定义" class="headerlink" title="2.1.1 线性表的定义"></a>2.1.1 线性表的定义</h3><p>线性表是具有相同数据类型的n(&gt;=0)个数据元素的有限序列，其中n为表长，当n=0时，线性表是一个空表。</p><p>用L命名线性表，其一般表示为：</p><p>L=（a<sub>1</sub>,a<sub>2</sub>,a<sub>3</sub>…a<sub>i</sub>,a<sub>i+1</sub>…a<sub>n</sub>）</p><p>a<sub>1</sub>是唯一的第一个元素，又称<strong>表头元素</strong>。</p><p>a<sub>n</sub>是为一个最后一个元素，又称<strong>表尾元素</strong>。</p><p><strong>线性表的逻辑特性：</strong></p><p>除第一个元素之外，每个元素有且仅有一个<strong>直接前驱</strong>。</p><p>除最后一个元素之外，每个元素有且只有一个<strong>直接后继</strong>。</p><p><strong>线性表的特点：</strong></p><ul><li>表中元素的个数有限</li><li>表中元素具有逻辑上的顺序性，表中元素有其先后次序。</li><li>表中元素都是数据元素，每个元素都是单个元素。</li><li>表中元素的数据类型都相同，意味着每个元素占有相同大小的存储空间。</li><li>表中元素具有抽象性，即今讨论元素间的逻辑关系，不考虑元素究竟表示什么内容。</li></ul><blockquote><p>线性表是一种逻辑结构，表示元素之间一对一的相邻关系，顺序表和链表是指存储结构。</p></blockquote><h3 id="2-1-2-线性表的基本操作"><a href="#2-1-2-线性表的基本操作" class="headerlink" title="2.1.2 线性表的基本操作"></a>2.1.2 线性表的基本操作</h3><p>线性表的主要操作如下：</p><div class="table-container"><table><thead><tr><th>InitLst(&amp;L)</th><th>初始化表，构造一个空的线性表。</th></tr></thead><tbody><tr><td>Length(L)</td><td>求表长，返回线性表L的长度，即L中数据元素的个数。</td></tr><tr><td>LocateElem(L,e)</td><td>按值查找操作，在表L中查找具有给定关键字值的元素。</td></tr><tr><td>GetElem(L,i)</td><td>按位查找操作，获取表L中第i个位置的元素的值。</td></tr><tr><td>ListInsert(&amp;l,i,e)</td><td>插入操作，在表L中的第i个位置上插入指定元素e。</td></tr><tr><td>ListDelete(&amp;L,I,&amp;e)</td><td>删除操作，删除表L中第i个位置的元素，并用e返回删除元素的值。</td></tr><tr><td>PrintList(L)</td><td>输出操作，按前后顺序输出线性表L的所有元素值。</td></tr><tr><td>Empty(L)</td><td>判空操作，若L为空表，则返回true，否则返回false。</td></tr><tr><td>DestroyList(&amp;L)</td><td>销毁操作，销毁线性表，并释放线性表L所占用的内存空间。</td></tr></tbody></table></div><h2 id="2-2-线性表的顺序表示"><a href="#2-2-线性表的顺序表示" class="headerlink" title="2.2 线性表的顺序表示"></a>2.2 线性表的顺序表示</h2><h3 id="2-2-1-线性表的定义"><a href="#2-2-1-线性表的定义" class="headerlink" title="2.2.1 线性表的定义"></a>2.2.1 线性表的定义</h3><p><strong>线性表的顺序存储又称顺序表。</strong></p><p>它是一组地址连续的存储单元依次存储线性表中的数据元素，从而使逻辑上相邻的两个元素在物理位置上也相邻。</p><p>顺序表的特点：表中元素的逻辑顺序与其物理顺序相同。</p><blockquote><p>线性表中的位序是从1开始的，数组中元素下标是从0开始的。</p></blockquote><p>假定线性表的元素类型为ElemType，线性表的顺序存储类型描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MaxSize 50 </span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>  ElemType data[MaxSize];<br>  <span class="hljs-keyword">int</span> length;<br>&#125;SqList;<br></code></pre></td></tr></table></figure><p>一维数组是可以静态分配的，也可以是动态分配的。</p><p>静态分配时，数组大小和空间事先已经固定，一旦空间占满，加入新的数据会产生溢出，进而使程序崩溃。</p><p>动态分配时，存储数组的空间是在程序执行过程中通过动态存储分配语句分配的，一旦数据空间占满，就另外开辟一块更大的存储空间，替换原来的存储空间，达到扩充存储数组空间的目的，不需要为线性表一次性地划分所有空间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> InitSize 100</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>  ElemType *data;<br>  <span class="hljs-keyword">int</span> MaxSize,length;<br>&#125;seqlist;<br></code></pre></td></tr></table></figure><p>C的初始动态分配语句：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">L.data=(ElemType*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(ElemType)*InitSize);<br></code></pre></td></tr></table></figure><p>C++的初始动态分配语句：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">L.data=<span class="hljs-keyword">new</span> ElemType[InitSize];<br></code></pre></td></tr></table></figure><blockquote><p>动态分配不是链式存储，同样是顺序存储结构，依然是随机存取，只是分配空间大小可以在运行时决定。</p></blockquote><p>顺序表的主要特点：可以随机访问，即通过首地址和元素序号可在时间O(1)内找到指定的元素。</p><p>顺序表的存储密度高，每个结点也只存储数据元素。</p><p>顺序表逻辑上相邻的元素物理上也相邻，插入和删除操作需要移动大量的元素。</p><h3 id="2-2-2-顺序表上基本操作的实现"><a href="#2-2-2-顺序表上基本操作的实现" class="headerlink" title="2.2.2 顺序表上基本操作的实现"></a>2.2.2 顺序表上基本操作的实现</h3><p>（1）插入操作</p><p>在顺序表L的第i（1&lt;=i&lt;=L.length+1）个位置插入新元素e。</p><p>若i的输入不合法，则返回false，表示插入失败；否则，将顺序表的第i个元素及其后的所有元素右移一个位置，腾出一个空位置插入新元素e，顺序表长度加1，插入成功，返回true。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ListInsert</span><span class="hljs-params">(SqList &amp;L,<span class="hljs-keyword">int</span> i ,ElemType e)</span></span>&#123;<br>  <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span>||i&gt;L.length+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">if</span>(L.length&gt;=MaxSize)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=L.length;j&gt;=i;j--)<br>    L.data[j]=L.data[j<span class="hljs-number">-1</span>];<br>  L.data[i<span class="hljs-number">-1</span>]=e;<br>  L.length++;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>最好情况：在表尾插入（即i=n+1），元素后移语句将不执行，时间复杂度为O(1)。</p><p>最坏情况：在表头插入（即i=1），元素后移语句执行n次，时间复杂度为O(n)。</p><p>平均情况：假设p<sub>i</sub>（p<sub>i</sub>=1/(n+1)）是在第i个位置上插入一个结点的概率，则在长度为n的线性表中插入一个结点时，所需移动结点的平均次数为：</p><script type="math/tex; mode=display">\sum_{i=1}^{n+1} p_{i}(n-i+1)=\sum_{i=1}^{n+1} \frac{1}{n+1}(n-i+1)=\frac{1}{n+1} \sum_{i=1}^{n+1}(n-i+1)=\frac{1}{n+1} \frac{n(n+1)}{2}=\frac{n}{2}</script><p>线性表插入算法平均时间复杂度为O(n)。</p><p>（2）删除操作</p><p>删除顺序表L的第i（1&lt;=i&lt;=L.length+1）个位置的元素，若成功则返回true，并将被删除的元素用引用变量e返回，否则返回false。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ListDelete</span><span class="hljs-params">(SqList &amp;L,<span class="hljs-keyword">int</span> i,ElemType e)</span></span>&#123;<br>  <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span>||i&gt;L.length+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  e=L.data[i<span class="hljs-number">-1</span>];<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i;j&lt;=L.length;j++)<br>    L.data[j<span class="hljs-number">-1</span>]=L.data[j];<br>  L.length--;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>最好情况：删除表尾元素（即i=n），无需移动元素，时间复杂度为O(1)。</p><p>最坏情况：删除表头元素（即i=1），需移动除第一个元素之外的所有元素，时间复杂度为O(n)。</p><p>平均情况：假设p<sub>i</sub>（p<sub>i</sub>=1/n）是删除第i个位置上结点的概率，则在长度为n的线性表中删除一个结点时，所需移动结点的平均次数为：</p><script type="math/tex; mode=display">\sum_{i=1}^{n} p_{i}(n-i)=\sum_{i=1}^{n} \frac{1}{n}(n-i)=\frac{1}{n} \sum_{i=1}^{n}(n-i)=\frac{1}{n} \frac{n(n-1)}{2}=\frac{n-1}{2}</script><p>线性表删除算法的平均时间复杂度为O(n)。</p><p>（3）按值查找</p><p>在顺序表L中查找第一个元素值等于e的元素，并返回其位序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">LocateElem</span><span class="hljs-params">(Sqlist L,ElemType e)</span></span>&#123;<br>  <span class="hljs-keyword">int</span> i;<br>  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;L.length;i++)<br>    <span class="hljs-keyword">if</span>(L.data[i]==e)<br>      <span class="hljs-keyword">return</span> i+<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>最好情况：查找的元素就在表头，仅需比较一次，时间复杂度为O(1)。</p><p>最坏情况：查找的元素在表尾（或不存在时），需要比较n次，时间复杂度为O(n)。</p><p>平均情况：假设p<sub>i</sub>（p<sub>i</sub>=1/n）是查找的元素在第i（1&lt;=i&lt;=L.length）个位置上的概率，则在长度为n的线性表中查找值为e的元素所需比较的平均次数为：</p><script type="math/tex; mode=display">\sum_{i=1}^{n} p_{i} \times i=\sum_{i=1}^{n} \frac{1}{n} \times i=\frac{1}{n} \frac{n(n+1)}{2}=\frac{n+1}{2}</script><p>线性表按值查找算法的平均时间复杂度为O(n)。</p><h2 id="2-3-线性表的链式表示"><a href="#2-3-线性表的链式表示" class="headerlink" title="2.3 线性表的链式表示"></a>2.3 线性表的链式表示</h2><p>链式存储线性表，不需要使用地址连续的存储单元，即不要求逻辑上相邻的元素在物理位置上也相邻，插入和删除操作不需要移动元素，只需要修改指针，但是也失去顺序表可随机存取的优点。</p><h3 id="2-3-1-单链表的定义"><a href="#2-3-1-单链表的定义" class="headerlink" title="2.3.1 单链表的定义"></a>2.3.1 单链表的定义</h3><p>线性表的链式存储又称单链表，是指通过一组任意的存储单元来存储线性表中的数据元素。</p><p>为了建立数据元素之间的线性关系，对每个链表结点，除存放元素自身的信息外，还需要存放一个指向其后继的指针。</p><p><img src="https://gitee.com/zxyss/blogimg/raw/master/img/20210423180726.jpg" alt=""></p><p>data：数据域，存放数据元素。</p><p>next：指针域，存放其后继结点的地址。</p><p>单链表结点类型描述：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span>&#123;</span><br>  ElemType data;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> *<span class="hljs-title">next</span>;</span><br>&#125;LNode,*LinkList;<br></code></pre></td></tr></table></figure><p>单链表附加指针域，存在浪费空间的缺点。单链表元素离散地分布在存储空间中，所以单链表是<code>非随机存取</code>的存储结构。</p><p>即不能直接找到表中某个特定的结点。查找某个特定的结点时，需要从头开始遍历，依次查找。</p><p>通常用<code>头指针</code>标识一个单链表，如单链表L，头指针为NULL时为一个空表。</p><p>为了操作方便，在单链表第一个结点之前附加一个结点，称为<code>头结点</code>。头结点的数据域可以不设任何信息，也可以记录表长等信息。</p><p>头结点的指针域指向线性表的第一个元素结点。</p><p><img src="https://gitee.com/zxyss/blogimg/raw/master/img/20210423180739.jpg" alt=""></p><p><strong>头结点与头指针的区分：</strong></p><p>不管带不带头结点，头指针始终指向链表的第一个结点，而头结点时带头结点的链表中的第一个结点，结点内通常不存储信息。</p><p><strong>引入头结点的优点：</strong></p><ol><li>由于第一个数据结点的位置被存放在头结点的指针域中，所以在链表的第一个位置上的操作和在表的其他位置上的操作一致，无需进行特殊处理。</li><li>无论链表是否为空，其头指针都指向头结点的非空指针（空表中头结点的指针与为空），因此空表和非空表的处理也就得到了统一。</li></ol><h3 id="2-3-2-单链表上基本操作的实现"><a href="#2-3-2-单链表上基本操作的实现" class="headerlink" title="2.3.2 单链表上基本操作的实现"></a>2.3.2 单链表上基本操作的实现</h3><ol><li><strong>采用头插法建立单链表</strong></li></ol><p>该方法从一个空表开始，生成新结点，并将读取到的数据存放到新结点的数据域中，然后将新结点插入到当前链表的表头，即头结点之后。</p><p><img src="https://gitee.com/zxyss/blogimg/raw/master/img/20210423180749.jpg" alt=""></p><p><strong>头插法建立单链表算法：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">LinkList <span class="hljs-title">List_HeadInsert</span><span class="hljs-params">(Linklist &amp;L)</span></span>&#123;<br>  LNode *s;<span class="hljs-keyword">int</span> x;<br>  L=(LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));<br>  L-&gt;next=NLLL;<br>  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br>  <span class="hljs-keyword">while</span>(x!=<span class="hljs-number">9999</span>)&#123;<br>    s=(LNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));<br>    s-&gt;data=x;<br>    s-&gt;next=L-&gt;next;<br>    L-&gt;next=x;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br>  &#125;<br>  <span class="hljs-keyword">return</span> L;<br>&#125;<br></code></pre></td></tr></table></figure><p>头插法建立单链表，读入数据的顺序与生成链表的顺序是相反的。</p><p>每个结点插入的时间为O(1)，设单链表长为n，总时间复杂度为O(n)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*随机产生n个元素的值，建立带表头结点的单链线性表L（头插法）*/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CreateListHead</span><span class="hljs-params">(LinkList *L,<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>  LinkList p;<br>  <span class="hljs-keyword">int</span> i;<br>  srand(time(<span class="hljs-number">0</span>));<br>  *l=(LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>  (*L)-&gt;next=<span class="hljs-literal">NULL</span>;              <span class="hljs-comment">//建立一个带头结点单链表</span><br>  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>    p=(LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<span class="hljs-comment">//生成新结点</span><br>    p-&gt;data=rand()%<span class="hljs-number">100</span>+<span class="hljs-number">1</span>;      <span class="hljs-comment">//随机生成100以内的数字</span><br>    p-&gt;next=(* L)-&gt;next;<br>    (*L)-&gt;next=p;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><strong>采用尾插法建立单链表</strong></li></ol><p>将结点插入到当前链表的表尾，为此必须增加一个尾指针r，使其始终指向当前链表的尾结点。</p><p><img src="https://gitee.com/zxyss/blogimg/raw/master/img/20210423180816.jpg" alt=""></p><p>尾插法建立单链表算法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">LinkList <span class="hljs-title">List_TailInsert</span><span class="hljs-params">(LinkList &amp;L)</span></span>&#123;<br>  <span class="hljs-keyword">int</span> x;<br>  L=(LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));<br>  LNode *s,*r=L;<br>  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;&amp;d&quot;</span>,%x);<br>  <span class="hljs-keyword">while</span>(x!=<span class="hljs-number">99999</span>)&#123;<br>    s=(LNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));<br>    s-&gt;data=x;<br>    r-&gt;next=s;<br>    r=s;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br>  &#125;<br>  r-&gt;next=<span class="hljs-literal">NULL</span>;<br>  <span class="hljs-keyword">return</span> L;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度为O(n)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*随机产生n个元素的值，建立带表头结点的单链线性表L（尾插法）*/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CreatListTail</span><span class="hljs-params">(LinkList *L,<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>  LinkList p,r;<br>  <span class="hljs-keyword">int</span> i;<br>  srand(time(<span class="hljs-number">0</span>));<br>  *L=(LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>  r=*L;<br>  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>    p=(LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>    p-&gt;data=rand()%<span class="hljs-number">100</span>+<span class="hljs-number">1</span>;<br>    r-&gt;next=p;<br>    r=p;<br>  &#125;<br>  r-&gt;next=<span class="hljs-literal">NULL</span>;    <span class="hljs-comment">//当前链表结束</span><br>&#125;<br></code></pre></td></tr></table></figure><ol><li><strong>按序号查找结点值</strong></li></ol><p>在单链表中从第一个结点出发，顺指针next域逐个往下搜索，直到找到第i个结点为止，否则返回最后一个结点指针域NULL。</p><p><strong>按序号查找结点值的算法如下：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">LNode *<span class="hljs-title">GetElem</span><span class="hljs-params">(LinkList L,<span class="hljs-keyword">int</span> i,ElemType *e)</span></span>&#123;<br>  <span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;<br>  LNode *p=L-&gt;next;<br>  <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> L;<br>  <span class="hljs-keyword">if</span>(&lt;<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>  <span class="hljs-keyword">while</span>(p&amp;&amp;j&lt;i)&#123;<br>     p=p-&lt;next;<br>   j++;<br>  &#125;<br>  <span class="hljs-keyword">if</span>(!p || j&gt;i)<br>    <span class="hljs-keyword">return</span> ERROR;<br>  *e=p-&gt;data;<br>  <span class="hljs-keyword">return</span> ok; <br>&#125;<br></code></pre></td></tr></table></figure><p>按序号查找操作时间复杂度为O(n)。</p><ol><li><strong>按值查找表结点</strong></li></ol><p>从单链表第一个结点开始，由前往后依次比较表中各结点数据域的值，若某结点数据域的值等于给定值e，则返回该结点的指针；若单链表没有这样的结点，则返回NULL。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">LNode *<span class="hljs-title">LocateElem</span><span class="hljs-params">(LinkList L,ElemType e)</span></span>&#123;<br>  LNode *p=L-&gt;next;<br>  <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>&amp;&amp;p-&gt;data!=e)<br>    p=p-&gt;next;<br>  <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><p>按值查找时间复杂度为O(n)。</p><ol><li><strong>插入结点操作</strong></li></ol><p>插入结点操作将值为 x的新结点插入到单链表的第 i 个位置上。先检查插入位置的合法性, 然后找到待插入位置的前驱结点，即第 i-1 个结点，再在其后插入新结点。</p><p>算法首先调用按序号查找算法 GetElem (L, i-1)，查找第 i-1 个结点。</p><p>假设返回的第 i-1 个结点为<em> p，然后令新结点</em> s 的指针域指向<em> p的后继结点，再令结点 </em> p 的指针域指向新插入 的结点* s。</p><p>实现插入操作代码片段：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1.</span> p=GetElem(L,i<span class="hljs-number">-1</span>);<br><span class="hljs-number">2.</span> s-&gt;next=p-&gt;next;<br><span class="hljs-number">3.</span> p-&gt;next=s;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/zxyss/blogimg/raw/master/img/20210423180832.jpg" alt=""></p><p><strong>对某一结点进行前插操作：</strong></p><p>以上面的算法为例，首先调用函数 GetElem () 找到第 i-1 个结点，即插入结点的前驱结点后，再对其执行后插操作。</p><p>由此可知，对结点的前插操作均可转化为后插操作，前提是从单链表的头结点开始顺序查找到其前驱结点，时间复杂度为O(n) 。</p><p>此外，可采用另一种方式将其转化为后插操作来实现，设待插入结点为<em> s,将</em> s 插入到<em> p的前面。我们仍然将</em> s 插入到 * p 的后面，然后将 p-&gt;data 与s-&gt;data交换，这样既满足了逻辑关系，又能使得时间复杂度为 O(1)。</p><p>算法的代码片段如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">s-&gt;next=p-&gt;next;<br>p-&gt;next=s;<br>temp=p-&gt;data;     <span class="hljs-comment">//交换数据域部分</span><br>p-&gt;data=s-&gt;data;<br>s-&gt;data=temp;<br></code></pre></td></tr></table></figure><p>在L中第i个位置之前插入新的元素e，L长度加1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">Status <span class="hljs-title">LinstInsert</span><span class="hljs-params">(LInkList *L,<span class="hljs-keyword">int</span> i ,ElemType e)</span></span>&#123;<br>  <span class="hljs-keyword">int</span> j;<br>  LinkList p,s;<br>  p=*L;<br>  j=<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span>(p&amp;&amp;j&lt;i)&#123;<br>    p=p-&gt;next;<br>    ++j;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (!p||j&gt;i)<br>    <span class="hljs-keyword">return</span> ERROR;<br>  s=(LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>  s-&gt;data=e;<br>  s-&gt;next=p-&gt;next;<br>  p-&gt;next=s;<br>  <span class="hljs-keyword">return</span> ok;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p><strong>删除结点</strong></p><p>删除结点操作是将单链表的第i个结点删除。</p></li></ol><p>先检查删除位置的合法性，后查找表中第i-1个结点，即被删除结点的前驱结点，再将其删除。</p><p><img src="https://gitee.com/zxyss/blogimg/raw/master/img/20210423180843.jpg" alt=""></p><p>假设结点<em>p为找到的被删除结点的前驱结点，仅需修改 </em>p的指针域，即将 <em> p的指针域next指向 </em>q的下一结点。</p><p>实现删除结点的代码片段：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">p=GetElem(L,i<span class="hljs-number">-1</span>);<br>q=p-&gt;next;<br>p-&gt;next=<span class="hljs-number">1</span>-&gt;next;<br><span class="hljs-built_in">free</span>(q);<br></code></pre></td></tr></table></figure><p>时间复杂度为O(n)。</p><p><strong>删除结点*p：</strong></p><p>要删除某个给定结点* p，通常的做法是先从链表的头结点开始顺序找到其前驱结点，然后再 执行删除操作，算法的时间复杂度为 O(n) 。</p><p>删除结点<em> p的操作可用删除</em> p 的后继结点操作来实现，实质就是将其后继结点的值赋予其自身，然后删除后继结点，也能使得时间复杂度为 O(1)。</p><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">q=p-&gt;next;<br>p-&gt;data=p-&gt;next-&gt;data;<br>p-&gt;next=q-&gt;next;<br><span class="hljs-built_in">free</span>(q);<br></code></pre></td></tr></table></figure><p>单链表第i个数据删除结点算法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">Status <span class="hljs-title">ListDelete</span><span class="hljs-params">(LinkList *L,<span class="hljs-keyword">int</span> i,ElemType *e)</span></span>&#123;<br>  <span class="hljs-keyword">int</span> j;<br>  LinkList p,q;<br>  p=*L;<br>  j=<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span>(p-&gt;next &amp;&amp; j&lt;i)&#123;<br>    p=p-&gt;next;<br>    ++j;<br>  &#125;<br>  <span class="hljs-keyword">if</span>(!(p-&gt;next) || j&gt;i)<br>    <span class="hljs-keyword">return</span> ERROR;<br>  q=p-&gt;next;<br>  p-&gt;next=q-&gt;next;<br>  *e=q-&gt;data;<br>  <span class="hljs-built_in">free</span>(q);<br>  <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><strong>求表长操作</strong></li></ol><p>求表长操作就是计算单链表中数据结点（不含头结点）的个数，需要从第一个结点开始顺序依次访问表中的每个结点，为此需要设置一个计数器变量，每访问一个结点，计数器加 1,直到访问到空结点为止。算法的时间复杂度为 O(n) 。</p><p> 需要注意的是，因为单链表的长度是不包括头结点的，因此不带头结点和带头结点的单链表在求表长操作上会略有不同。对不带头结点的单链表，当表为空时，要单独处理。</p><h3 id="单链表结构与顺序存储结构优缺点"><a href="#单链表结构与顺序存储结构优缺点" class="headerlink" title="单链表结构与顺序存储结构优缺点"></a>单链表结构与顺序存储结构优缺点</h3><p><img src="https://gitee.com/zxyss/blogimg/raw/master/img/20210423180906.jpg" alt=""></p><h3 id="2-3-3-静态链表"><a href="#2-3-3-静态链表" class="headerlink" title="2.3.3 静态链表"></a>2.3.3 静态链表</h3><p>静态链表借助数组来描述线性表的链式存储结构，结点也有数据域<code>data</code>和指针域<code>next</code>，这里的指针是结点的相对地址（数组下标），又称游标。</p><p>让数组的元素都是由两个数据域组成，<code>data</code>和 <code>cur</code>。</p><p>也就是说，数组的每个下标都对应一个 data 和一个 cur。</p><p>数据域data,用来存放数据元素，也就是通常我们要处理的数据; 而游标cur相当于单链表中的 next 指针，存放该元素的后继在数组中的下标。</p><p><strong>线性表的静态链表存储结构</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> MaxSize 1000</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>  ElemType data;<br>  <span class="hljs-keyword">int</span> cur;<br>&#125;StaticLinkList[MaxSize];<br></code></pre></td></tr></table></figure><p>静态链表以cur==-1作为其结束的标志。</p><p>静态链表的插入、删除操作与动态链表的相同，只需要修改指针，而不需要移动元素。</p><p><strong>静态链表优缺点：</strong></p><ul><li>优点：在插入和删除操作时，只需要修改游标，不需要移动元素，从而改进了在顺序存储结构中的插入和删除操作需要移动大量元素的缺点。</li><li>缺点：没有解决连续存储分配带来的表长难以确定的问题，失去了顺序存储结构随机存取的特性。</li></ul><h3 id="2-3-4-循环链表"><a href="#2-3-4-循环链表" class="headerlink" title="2.3.4 循环链表"></a>2.3.4 循环链表</h3><p>将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表（ circular linked list)。</p><p><img src="https://gitee.com/zxyss/blogimg/raw/master/img/20210423180932.jpg" alt=""></p><p>在循环单链表中，表尾结点<em>r的next域指向L，表中没有指向NULL的结点，因此，<strong>循环单链表的判空条件</strong>不是头结点的指针是否为空，而是<em>*它是否等于头指针</em></em>。</p><p>循环链表带有头结点的空链表：</p><p><img src="https://gitee.com/zxyss/blogimg/raw/master/img/20210423180947.jpg" alt=""></p><p>非空的循环链表：</p><p><strong><img src="https://gitee.com/zxyss/blogimg/raw/master/img/20210423181009.jpg" alt=""></strong></p><p>在单链表中只能从表头结点开始往后顺序遍历整个链表，而循环单链表可以从表中的任意一 个结点开始遍历整个链表。</p><p>有时对单链表常做的操作是在表头和表尾进行的，此时对循环单链表不设头指针而仅设尾指针，从而使得操作效率更高。其原因是，若设的是头指针，对表尾进行操作需O(n)的时间复杂度，而若设的是尾指针 r, r-&gt;next 即为头指针，对于表头与表尾进行操作都只需要 O(1)的时间复杂度。</p><p><strong>例子：</strong></p><p>两个循环链表合并成一个表</p><p><img src="https://gitee.com/zxyss/blogimg/raw/master/img/20210423181022.jpg" alt=""></p><p>合并操作：</p><p><img src="https://gitee.com/zxyss/blogimg/raw/master/img/20210423181036.jpg" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">p=rearA-&gt;next;           <span class="hljs-comment">//保存A表的头结点 1</span><br>rearA-next=rearB-&gt;next-&gt;next; <span class="hljs-comment">//将本是指向表B的第一个结点（不是头结点）赋值给//rearA-&gt;next 2</span><br>rearB-&gt;next=p;          <span class="hljs-comment">//将原表A的头结点赋值给rearB-&gt;next 3</span><br><span class="hljs-built_in">free</span>(p);<br></code></pre></td></tr></table></figure><h3 id="2-3-5-双链表"><a href="#2-3-5-双链表" class="headerlink" title="2.3.5 双链表"></a>2.3.5 双链表</h3><p>双链表（double linkwd list）是在单链表的每个结点中，再设置一个指向其前驱结点的指针域。</p><p>所以双链表有两个指针域，<code>prior</code>和<code>next</code>，一个指向直接前驱，一个指向直接后继。</p><p><img src="https://gitee.com/zxyss/blogimg/raw/master/img/20210423181051.jpg" alt=""></p><p>双链表结点类型描述</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DNode</span>&#123;</span><br>  ElemType data;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DNode</span> *<span class="hljs-title">prior</span>,*<span class="hljs-title">next</span>;</span><br>&#125;DNode,*DLinkList;<br></code></pre></td></tr></table></figure><p>双向链表的循环带头结点的空链表：</p><p><img src="https://gitee.com/zxyss/blogimg/raw/master/img/20210423181102.jpg" style="zoom:50%;" /></p><p>非空的循环的带头结点的双向链表：</p><p><img src="https://gitee.com/zxyss/blogimg/raw/master/img/20210423181137.jpg" alt=""></p><ol><li><strong>双链表的插入</strong></li></ol><p>在双链表中p所指的结点之后插入结点*s：</p><p><img src="https://gitee.com/zxyss/blogimg/raw/master/img/20210423181206.jpg" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1.</span>s-&gt;prior=p;<br><span class="hljs-number">2.</span>s-&gt;next=p-&gt;next;<br><span class="hljs-number">3.</span>p-&gt;next-&gt;prior=s;<br><span class="hljs-number">4.</span>p-&gt;next=s;<br></code></pre></td></tr></table></figure><ol><li><strong>双链表的删除</strong></li></ol><p>删除双链表中结点<em>p的后继结点 </em>q</p><p><img src="https://gitee.com/zxyss/blogimg/raw/master/img/20210423181227.jpg" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">p-&gt;prior-&gt;next=p-&gt;next;<br>p-&gt;next-&gt;prior=p-&gt;prior;<br><span class="hljs-built_in">free</span>(p);<br></code></pre></td></tr></table></figure><ol><li><strong>循环双链表</strong></li></ol><p>头结点的prior指针还要指向表尾结点：</p><p><img src="https://gitee.com/zxyss/blogimg/raw/master/img/20210423181244.jpg" alt=""></p><p>循环双链表L中，某结点*p为尾结点时，p-&gt;nex==L;</p><p>当循环双链表为空表时，其头结点的prior域和next域都等于L。</p>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/04/22/hello-world/"/>
    <url>/2021/04/22/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>第三章-栈和队列</title>
    <link href="/2021/04/15/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <url>/2021/04/15/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="第三章-栈和队列"><a href="#第三章-栈和队列" class="headerlink" title="第三章 栈和队列"></a>第三章 栈和队列</h1><p>【考纲内容】</p><p>（一）栈和队列的基本概念</p><p>（二）栈和队列的顺序存储结构</p><p>（三）栈和队列的链式存储结构</p><p>（四）栈和队列的应用</p><p>（五）特殊矩阵的压缩存储</p><p>【知识框架】</p><p><img src="https://gitee.com/zxyss/blogimg/raw/master/img/20210423202409.jpg" alt=""></p><h2 id="3-1-栈的定义"><a href="#3-1-栈的定义" class="headerlink" title="3.1 栈的定义"></a>3.1 栈的定义</h2><h3 id="3-1-1-栈的基本概念"><a href="#3-1-1-栈的基本概念" class="headerlink" title="3.1.1 栈的基本概念"></a>3.1.1 栈的基本概念</h3><ol><li><strong>栈的定义</strong></li></ol><p><strong>栈（stack）是只允许在一端进行插入和删除操作的线性表。</strong></p><p>首先栈是一种线性表，限定这种线性表只能在某一端进行插入和删除操作。</p><p><strong>栈顶（Top）</strong>：线性表允许进行插入删除的那一端。</p><p><strong>栈底（Bottom）</strong>：固定的，不允许进行插入和删除的一端。</p><p><strong>空栈</strong>：不含任何元素的空表。</p><p>栈又称为后进先出（Last In First Out）的线性表，简称LIFO结构。也就是说，栈底是固定的，最先进栈的只能在栈底。</p><p><strong>注</strong>：栈首先是一个线性表，也就是说栈元素具有线性关系，即前驱后继关系。只不过是一种特殊的线性表，</p><p><strong>栈的定义是说在线性表的表尾进行插入和删除操作，这里表尾是指栈顶，而不是栈底。</strong></p><ol><li><strong>栈的基本操作</strong>（抽象数据类型）</li></ol><div class="table-container"><table><thead><tr><th>InitStack(&amp; S)</th><th>初始化一个空栈S</th></tr></thead><tbody><tr><td>StackEmpty(S)</td><td>判断一个栈是否为空，若栈S为空则返回True，否则返回False</td></tr><tr><td>Push(&amp;S,x)</td><td>进栈，若栈S未满，则将x加入使之成为新栈顶</td></tr><tr><td>Pop(&amp;S,&amp;x)</td><td>出栈，若栈S非空，则弹出栈顶元素，并用x返回</td></tr><tr><td>GetTop(S,&amp;x)</td><td>读栈顶元素，若栈S非空，则用x返回栈顶元素</td></tr><tr><td>DestoryStack(&amp;S)</td><td>栈销毁，并释放栈S占用的存储空间（&amp; 表示引用调用）</td></tr></tbody></table></div><h3 id="3-1-2-栈的顺序存储结构"><a href="#3-1-2-栈的顺序存储结构" class="headerlink" title="3.1.2 栈的顺序存储结构"></a>3.1.2 栈的顺序存储结构</h3><ol><li><strong>顺序栈的实现</strong></li></ol><p>采用顺序存储的栈称为<code>顺序栈</code>。</p><p>它利用一组抵制连续的存储单元存放自栈底带栈顶的数据元素，同时附设一个指针（top）指示当前栈顶元素的位置。</p><p><strong>栈的结构定义</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> MaxSize 100</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>  ElemType data[MaxSize];<br>  <span class="hljs-keyword">int</span> top;<br>&#125;SqStack;<br></code></pre></td></tr></table></figure><p><strong>栈顶指针</strong>：S.top，初始时设置S.top==-1；栈顶元素S.data[S.top];</p><p><strong>进栈操作</strong>：栈不满时，栈顶指针先加1，再送值到栈顶元素。</p><p><strong>出栈操作</strong>：栈非空时，先取栈顶元素值，再将栈顶指针减1。</p><p><strong>栈空条件</strong>：S.top==-1；</p><p><strong>栈满条件</strong>：S.top==MaxSize-1;</p><p><strong>栈长</strong>：S.top+1;</p><p>假设有个栈，StackSize为5，普通栈，空栈，栈满情况如下：</p><p><img src="https://gitee.com/zxyss/blogimg/raw/master/img/20210423202426.jpg" alt=""></p><ol><li><strong>顺序栈的基本操作</strong></li></ol><p>顺序栈常用基本运算：</p><p>（1）<strong>初始化</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InitStack</span><span class="hljs-params">(SqStack &amp;S)</span></span>&#123;<br>  S.top=<span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）<strong>判空栈</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">StackEmpty</span><span class="hljs-params">(SqStack &amp;S)</span></span>&#123;<br>  <span class="hljs-keyword">if</span>(S.top==<span class="hljs-number">-1</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">else</span><br>    retuen <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（3）<strong>进栈</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Push</span><span class="hljs-params">(SqStack &amp;S,ElemType x)</span></span>&#123;<br>  <span class="hljs-keyword">if</span>(S.top=MaxSize<span class="hljs-number">-1</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  S.data[++S.top]=x;   <span class="hljs-comment">//指针先加1，再入栈</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/zxyss/blogimg/raw/master/img/20210423202438.jpg" alt=""></p><p>栈不满时，top先加1，再入栈。</p><p>（4）<strong>出栈</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Pop</span><span class="hljs-params">(SqStack &amp;S,ElemType &amp;x)</span></span>&#123;<br>  <span class="hljs-keyword">if</span>(S.top==<span class="hljs-number">-1</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  x=S.data[S.top--];<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（5）<strong>读取栈顶元素</strong> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">GetTop</span><span class="hljs-params">(SqStack S,ElemType &amp;x)</span></span>&#123;<br>  <span class="hljs-keyword">if</span>(S.top==<span class="hljs-number">-1</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  x.data[S.top];<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>仅为读取栈顶元素，并没有出栈操作，因此原栈顶元素依然保留在栈中。</p><p>注意: 这里 top 指向的是栈顶元素，所以<code>进栈操作</code>为 <code>S.data[++S.top]=x</code>, <code>出栈操作</code>为<code>x=S.data[S.top--]</code>。</p><p>若<code>栈顶指针初始化</code>为<code>S.top=0</code>，即top指向栈顶元素的下一位置，则<code>入栈操作</code>变为<code>S.data[S.top++]=x;</code> <code>出栈操作</code>变为 <code>x=S.data[--S.top]</code>。</p><p>相应的栈空、栈满条件也会发生变化。</p><ol><li><strong>共享栈</strong></li></ol><p>数组有两个端点，两个栈有两个栈底，让一个栈的栈底为数组的始端，即下标为 0 处，另一个栈为栈的末端，即下标为数组长度 n-1处。</p><p>这样，两个栈如果增加元素，就是两端点向中间延伸。</p><p><img src="https://gitee.com/zxyss/blogimg/raw/master/img/20210423202448.jpg" alt=""></p><p>其实关键思路是：它们是在数组的两端，向中间靠笼。top1 和 top2 是栈 1 和栈 2 的栈顶指针，可以想象，只要它们俠不见面，两个栈就可以一直使用。</p><p>从这里也就可以分析出来，栈 1 为空时，就是 top1 等于一1 时; 而当 top2 等于 n时，即是栈 2 为空时，那什么时候栈满?</p><p>极端的情况，若栈 2 是空栈，栈 1 的 top 1 等于 n-1时，就是栈 1 满了。</p><p>反之，当栈 1 为空栈时，top2 等于 0 时，为栈 2 满。</p><p>但更多的情况，两个栈见面之时，也就是两个指针之间相差 1 时，即 top1+1==top 2 为栈满。</p><h3 id="3-1-3-栈的链式存储结构"><a href="#3-1-3-栈的链式存储结构" class="headerlink" title="3.1.3 栈的链式存储结构"></a>3.1.3 栈的链式存储结构</h3><p>栈的链式存储结构简称为<code>链栈</code>。</p><p>对于链栈来说，是不需要头结点的，也不存在栈满的情况，除非是内存已经没有可以使用的空间。</p><p>对空栈来说，链表原定义是头指针指向空，链栈的空就是top=NULL的时候。</p><p><img src="https://gitee.com/zxyss/blogimg/raw/master/img/20210423202505.jpg" style="zoom:50%;" /></p><p><strong>链栈结构代码</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">StackNode</span>&#123;</span><br>  SElemType data;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">StackNode</span> *<span class="hljs-title">next</span>;</span><br>&#125;StackNode,*LinkStackPtr;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LinkStack</span>&#123;</span><br>  LinkStackPtr top;<br>  <span class="hljs-keyword">int</span> count;<br>&#125;LinkStack;<br></code></pre></td></tr></table></figure><ol><li><strong>进栈操作</strong></li></ol><p>链栈的进栈Push操作，假设元素值为e的新结点是s，top为栈顶指针：</p><p><img src="https://gitee.com/zxyss/blogimg/raw/master/img/20210423202528.jpg" style="zoom:50%;" /></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">Status <span class="hljs-title">Push</span><span class="hljs-params">(LinkStack *S,SElemType e)</span></span>&#123;<br>  LinkStackPtr s=(LinkStackPtr)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(StackNode));<br>  s-&gt;data=e;<br>  s-&gt;next=S-&gt;top;<br>  S-&gt;top=s;<br>  S-&gt;count++;<br>  <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><strong>出栈操作</strong></li></ol><p>假设变量p用来存储要删除的栈顶顶点，将栈顶指针下移一位，最后释放p即可。</p><p><img src="https://gitee.com/zxyss/blogimg/raw/master/img/20210423202542.jpg" style="zoom:50%;" /></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">Status <span class="hljs-title">Pop</span><span class="hljs-params">(LinkStack *S,SElemType *e)</span></span>&#123;<br>  LinkStackPtr p;<br>  <span class="hljs-keyword">if</span>(StackEmpty(*S))<br>    <span class="hljs-keyword">return</span> ERROR;<br>  *e=S-&gt;top-&gt;data;<br>  p=S-&gt;top;<br>  S-&gt;top=S-&gt;top-&gt;next;<br>  <span class="hljs-built_in">free</span>(p);<br>  S-&gt;count--;<br>  <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>进栈和出栈的时间复杂度均为O(1)。</strong></p><p>在栈的使用过程中元素变化不可预料，最好用链栈，反之，变化在可控范围内，使用顺序栈会好一些。</p><h3 id="3-1-4-栈的应用-斐波那契数列"><a href="#3-1-4-栈的应用-斐波那契数列" class="headerlink" title="3.1.4 栈的应用-斐波那契数列"></a>3.1.4 栈的应用-斐波那契数列</h3><script type="math/tex; mode=display">F(n)=\left\{\begin{array}{l}0, \quad \text { 当 } n=0 \\1, \text { 当 } n=1 \\F(n-1)+F(n-2), \quad \text { 当 } n>1\end{array}\right.</script><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//打印前40位斐波那契数列</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">int</span> i;<br>  <span class="hljs-keyword">int</span> a[<span class="hljs-number">40</span>];<br>  a[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>  a[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,a[<span class="hljs-number">0</span>]);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,a[<span class="hljs-number">1</span>]);<br>  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">2</span>;i&lt;<span class="hljs-number">40</span>;i++)&#123;<br>    a[i]=a[i<span class="hljs-number">-1</span>]=a[i<span class="hljs-number">-2</span>];<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,a[i]);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//斐波那契数列递归实现</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Fbi</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;<br>  <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">return</span> i==<span class="hljs-number">0</span>?<span class="hljs-number">0</span>:<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">return</span> Fbi(i<span class="hljs-number">-1</span>)+Fbi(i<span class="hljs-number">-2</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">int</span> i;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">40</span>;i++)<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,fbi(i));<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>递归定义：</strong></p><p>把一个直接调用自己活着通过一系列的调用语句间接地调用自己的函数，称作递归函数。</p><p>每个递归定义必须至少有一个条件，满足时递归不再进行，即不饮用自身而是返回值退出。</p><h3 id="3-1-5-栈在括号匹配中的应用"><a href="#3-1-5-栈在括号匹配中的应用" class="headerlink" title="3.1.5 栈在括号匹配中的应用"></a>3.1.5 栈在括号匹配中的应用</h3><p>假设表达式中允许包含两种括号: 圆括号和方括号，其嵌套的顺序任意即([] ())或[([][])]等均 为正确的格式，[(])或([O)或(O]均为不正确的格式。 考虑下列括号序列:</p><p><img src="https://gitee.com/zxyss/blogimg/raw/master/img/20210423202602.jpg" alt=""></p><p>分析如下:<br>1 ) 计算机接收第 1 个括号“ [“后，期待与之匹配的第 8 个括号 “]”出现。<br>2) 获得了第 2 个括号“(“，此时第 1 个括号“ [ “暂时放在一边，而急迫期待与之匹配的第 7 个括号 “)”出现。<br>3) 获得了第 3 个括号”[“，此时第 2 个括号 “ (“ 暂时放在一边，而急迫期待与之匹配的第 4 个括号“]”出现。第 3 个括号的期待得到满足，消解之后，第 2 个括号的期待匹配又 成为当前最急迫的任务。<br>4）以此类推，可见该处理过程与栈的思想吻合。 算法的思想如下:<br>1）初始设置一个空栈，顺序读入括号。<br>2）若是右括号，则或者使置于栈顶的最急迫期待得以消解，或者是不合法的情况（括号序 列不匹配，退出程序)。<br>3) 若是左括号，则作为一个新的更急迫的期待压入栈中，自然使原有的在栈中的所有未消 解的期待的急迫性降了一级。算法结束时，栈为空，否则括号序列不匹配。</p><h2 id="3-2-队列"><a href="#3-2-队列" class="headerlink" title="3.2 队列"></a>3.2 队列</h2><h3 id="3-2-1-队列的基本概念"><a href="#3-2-1-队列的基本概念" class="headerlink" title="3.2.1 队列的基本概念"></a>3.2.1 队列的基本概念</h3><ol><li><strong>队列的定义</strong></li></ol><p><strong>队列（queue）</strong>是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。</p><p>队列是一种<code>先进先出（First In First Out）</code>的<code>线性表</code>，简称<code>FIFO</code>。</p><p>允许插入的一端称为<code>队尾</code>，允许删除的一端称为<code>队头</code>。</p><p><code>空队列</code>：不含任何元素的空表</p><p><img src="https://gitee.com/zxyss/blogimg/raw/master/img/20210423202625.jpg" alt=""></p><ol><li><strong>队列的抽象数据类型</strong></li></ol><div class="table-container"><table><thead><tr><th>InitQueue(*Q)</th><th>初始化操作，建立一个空队列Q</th></tr></thead><tbody><tr><td>DestoryQueue(*Q)</td><td>若队列Q存在，则销毁它</td></tr><tr><td>ClearQueue(*Q)</td><td>将队列Q清空</td></tr><tr><td>QueueEmpty(Q)</td><td>若队列Q为空，返回true，否则返回false</td></tr><tr><td>GetHead(Q,*e)</td><td>若队列Q存在且非空，用e返回队列Q的队头元素</td></tr><tr><td>EnQueue(*Q,e)</td><td>若队列Q存在，插入新元素e到队列Q中并成为队尾元素</td></tr><tr><td>DeQueue(<em>Q,</em>e)</td><td>删除队列Q中对头元素，并用e返回其值</td></tr><tr><td>QueueLength(Q)</td><td>返回队列Q的元素个数</td></tr></tbody></table></div><h3 id="3-2-2-队列的顺序存储结构"><a href="#3-2-2-队列的顺序存储结构" class="headerlink" title="3.2.2 队列的顺序存储结构"></a>3.2.2 队列的顺序存储结构</h3><ol><li><strong>队列的顺序存储</strong></li></ol><p>队列的顺序实现是指分配一块连续的存储单元存放队列中的元素，并附设两个指针：<code>队头指针 front</code> 指向队头元素, <code>队尾指针 rear</code>指向队尾元素的下一个位置。</p><p>队列的顺序存储类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MaxSize 50</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>  ElemType data[MaxSize];<br>  <span class="hljs-keyword">int</span> front,rear;<br>&#125;SqQueue;<br></code></pre></td></tr></table></figure><p>初始状态（队空条件）：Q.front==Q.rear==0.</p><p>进队操作：队不满时，先送值到队尾元素，再将队尾指针加1。</p><p>出队操作：队不空时，先取队头元素值，再将队头指针加1。</p><p><img src="https://gitee.com/zxyss/blogimg/raw/master/img/20210423202645.jpg" alt=""></p><p>顺序队列缺点：</p><p>图 (a)所示为队列的初始状态，有 Q. front==Q.rear==0 成立，该条件可以作为队列判 空的条件。</p><p>但不能否用 Q.rear==Maxsize 作为队列满的条件，(d)中，队列中 仅有一个元素，但仍满足该条件。这时入队出现“上溢出”，但这种溢出并不是真正的溢出，在 data 数组中依然存在可以存放元素的空位置，所以是一种“假溢出”。</p><ol><li><strong>循环队列</strong></li></ol><p>把存储队列的表从逻辑上视为一个环，这种头尾相接的顺序存储结构称为<code>循环队列</code>。</p><p>初始时：Q.feont=Q.rear=0。</p><p>队首指针进1:Q.front=(Q.front+1)%MaxSize。</p><p>队尾指针进1:Q.rear=(Q.rear+1)%MaxSize。</p><p>出队入队时：指针都按顺时针方向进1。</p><p>那么,循环队列队空和队满的判断条件是: Q. front==Q.rear。</p><p> 若入队元素的速度快于出队元素的速度，则队尾指针很快就会赶上队首指针，如图 d(1)所示， 此时可以看出队满时也有 Q.front==Q.rear。循环队列出入队示意图如图 所示。</p><p><strong>为了区分对空还是队满，三种处理方式：</strong></p><p>1) 牺牲一个单元来区分队空和队满，入队时少用一个队列单元，这是一种较为普遍的做法, 约定以“队头指针在队尾指针的下一位置作为队满的标志”，如图d(2)所示。</p><p><code>队满条件</code>: (Q.rear+1) %MaxSize==Q.front。<br><code>队空条件仍</code>: Q.front==Q.rear。<br><code>队列中元素的个数</code>: (Q.rear-Q.front+MaxSize) % MaxSize。</p><p>2）类型中增设表示元素个数的数据成员。</p><p>队空的条件为 Q .size==0 ;</p><p>队满的条件为:Q.size==MaxSize。</p><p>这两种情况都有 Q .$ front==Q.rear。</p><p>3) 类型中增设 tag 数据成员，以区分是队满还是队空。tag 等于 0 时，若因删除导致<br>Q. front ==Q . rear, 则为队空; </p><p>tag 等于 1 时，若因插入导致 Q. front== Q . rear, 则为队满。</p><p><img src="https://gitee.com/zxyss/blogimg/raw/master/img/20210423202656.jpg" alt=""></p><ol><li><strong>循环队列的操作</strong></li></ol><p>（1）初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InitQueue</span><span class="hljs-params">(SqQueue &amp;Q)</span></span>&#123;<br>  Q.rear=Q.front=<span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）判空队</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">(SqQueue Q)</span></span>&#123;<br>  <span class="hljs-keyword">if</span>(Q.rear==Q.front)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（3）入队</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">EnQueue</span><span class="hljs-params">(SqQueue &amp;Q,ElemType x)</span></span>&#123;<br>  <span class="hljs-keyword">if</span>(Q.rear+<span class="hljs-number">1</span>)%MaxSize==Q.front)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  Q.data[Q.rear]=x;<br>  Q.rear=(Q.rear+<span class="hljs-number">1</span>)%MaxSize;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（4）出队</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">DeQueue</span><span class="hljs-params">(SqQueue %Q,ElemType &amp;x)</span></span>&#123;<br>  <span class="hljs-keyword">if</span>(Q.rear==Q.front)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  x=Q.data[Q.front];<br>  Q.front=(Q.front+<span class="hljs-number">1</span>)%MaxSize;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-3-队列的链式存储结构"><a href="#3-2-3-队列的链式存储结构" class="headerlink" title="3.2.3 队列的链式存储结构"></a>3.2.3 队列的链式存储结构</h3><ol><li><strong>队列的链式存储</strong></li></ol><p>队列的链式表示称为链队列，实际上是一个同时带有队头指针和队尾指针的单链表，头指针指向队头结点，尾指针指向队尾结点，即单链表的最后一个结点，即尾进头出。</p><p><img src="https://gitee.com/zxyss/blogimg/raw/master/img/20210423202740.jpg" alt=""></p><p>空队列时，front和rear都指向头结点</p><p><img src="https://gitee.com/zxyss/blogimg/raw/master/img/20210423202709.jpg" style="zoom:50%;" /></p><p>队列的链式存储类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>  ElemType data;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LinkNode</span> *<span class="hljs-title">next</span>;</span><br>&#125;LinkNode;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>  LinkNode *front,*rear;<br>&#125;LinkQueue;<br></code></pre></td></tr></table></figure><p>当Q.front==NULL且Q.rear==NULL时，链队列为空。</p><ol><li><strong>链式队列基本操作</strong></li></ol><p>（1）初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">IniQueue</span><span class="hljs-params">(LinkQueue &amp;Q)</span></span>&#123;<br>  Q.front=Q.rear=(LinkNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LinkNode));<br>  Q.front-&gt;next=<span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）判空队</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">IsEmpty</span><span class="hljs-params">(LinkQueue Q)</span></span>&#123;<br>  <span class="hljs-keyword">if</span>(q.front==Q.rear)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（3）入队</p><p>入队时, 建立一个新结点，将新结点插入到链表的尾部，并改让 Q.rear 指向这个新插入的结点（若原队 列为空队，则令Q .front 也指向该结点)。</p><p><img src="https://gitee.com/zxyss/blogimg/raw/master/img/20210423202810.jpg" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">EnQueue</span><span class="hljs-params">(LinkQueue &amp;Q,ElemType &amp;x)</span></span>&#123;<br>  LinkNode *s=(LinkNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));<br>  s-&gt;data=x;<br>  s-&gt;next=<span class="hljs-literal">NULL</span>;<br>  Q.rear-&gt;next=s;  <span class="hljs-comment">//拥有元素e新结点s赋值给原队尾结点的后继-1</span><br>  Q.rear=s;        <span class="hljs-comment">//把当前的s设置为队尾结点，rear指向s-2</span><br>&#125;<br></code></pre></td></tr></table></figure><p>（4）出队</p><p>出队时, 首先判断队是否为空, 若不空, 则取出队头元素, 将其从链表中摘除, 并让 Q.front<br>指向下一个结点（若该结点为最后一个结点，则置 Q.front 和 Q.rear 都为 NULL）。</p><p><img src="https://gitee.com/zxyss/blogimg/raw/master/img/20210423202824.jpg" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">DeQueue</span><span class="hljs-params">(LinkQueue &amp;Q,ElemType &amp;x)</span></span>&#123;<br>  <span class="hljs-keyword">if</span>(Q.front==Q.rear)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  LinkNode *p=Q.front-&gt;next;   <span class="hljs-comment">//欲删除的队头结点暂存给p--1</span><br>  x=p-&gt;data;                   <span class="hljs-comment">//欲删除的队头结点的值赋值给x</span><br>  Q.front-&gt;next=p-&gt;next;       <span class="hljs-comment">//原队头结点后继p-&gt;next赋值给头结点后继---2</span><br>  <span class="hljs-keyword">if</span>(Q.rear==p)<br>    Q.rear=Q.front;            <span class="hljs-comment">//原队列只有一个结点，删除后变空</span><br>  <span class="hljs-built_in">free</span>(p);<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-4-双端队列"><a href="#3-2-4-双端队列" class="headerlink" title="3.2.4 双端队列"></a>3.2.4 双端队列</h3><p>双端队列是指允许两端都可以进行入队和出队操作的队列，如图所示。其元素的逻辑结 构仍是线性结构。</p><p>将队列的两端分别称为<code>前端</code>和<code>后端</code>，两端都可以入队和出队。</p><p><img src="https://gitee.com/zxyss/blogimg/raw/master/img/20210423202935.jpg" alt=""></p><p>在双端队列进队时，前端进的元素排列在队列中后端进的元素的前面，后端进的元素排列在队列中前端进的元素的后面。在双端队列出队时，无论是前端还是后端出队，先出的元素排列在后出的元素的前面。</p><p><strong>输山受限的双端队列</strong>：允许在一端进行插入和删除，但在另一端只允许插入的双端队列称为输出受限的双端队列。</p><p><img src="https://gitee.com/zxyss/blogimg/raw/master/img/20210423180408.jpg" alt=""></p><p><strong>输入受限的双端队列</strong>：允许在一端进行插入和删除，但在另一端只允许删除的双端队列称为输入受限的双端队列。</p><p>若限定双端队列从某个端点插入的元素只能从该端点删除， 则该双端队列就阅变为两个栈底相邻接的栈。</p><p><img src="https://gitee.com/zxyss/blogimg/raw/master/img/20210423202950.jpg" alt=""></p><h2 id="3-4-特殊矩阵的压缩存储"><a href="#3-4-特殊矩阵的压缩存储" class="headerlink" title="3.4 特殊矩阵的压缩存储"></a>3.4 特殊矩阵的压缩存储</h2><h3 id="3-4-1-数组的定义"><a href="#3-4-1-数组的定义" class="headerlink" title="3.4.1 数组的定义"></a>3.4.1 数组的定义</h3><p>数组是由 n(n&gt;1)个相同类型的数据元素构成的<code>有限序列</code>，<strong>每个数据元素称为一个数组元素</strong>，每个元素在 n 个线性关系中的序号称为该<code>元素的下标</code>，下标的取值范围称为<code>数组的维界</code>。 </p><p><strong>数组与线性表的关系</strong>：数组是线性表的推广。</p><p>一维数组可视为一个线性表; 二维数组可视为 其元素也是定长线性表的线性表，以此类推。</p><p>数组一旦被定义，其维数和维界就不再改变。因此， 除结构的初始化和销毁外，数组只会有存取元素和修改元素的操作。</p><h3 id="3-4-2-数组的存储结构"><a href="#3-4-2-数组的存储结构" class="headerlink" title="3.4.2 数组的存储结构"></a>3.4.2 数组的存储结构</h3><p>以一维数组A[0…n-1]为例，其存储结构关系式为</p><script type="math/tex; mode=display">\operatorname{LOC}\left(a_{i}\right)=\operatorname{LOC}\left(a_{0}\right)+i \times L(0 \leq i<n)</script><p>其中，L 是每个数组元素所占的存储单元。</p><p>对于多维数组，有两种映射方法：按行优先和按列优先。以二维数组为例，按行优先存储的 基本思想是：先行后列，先存储行号较小的元素，行号相等先存储列号较小的元素。设二维数组 的行下标与列下标的范围分别为[0.h<sub>1</sub>]与 [0.h<sub>2</sub>]则存储结构关系式为</p><script type="math/tex; mode=display">\operatorname{LOC}\left(a_{i, j}\right)=\operatorname{LOC}\left(a_{0,0}\right)+\left[i \times\left(h_{2}+1\right)+j\right] \times L</script><p>例：对于数组A<sub>2*3</sub>,按行优先方式在内存中存储形式：</p><p><img src="https://gitee.com/zxyss/blogimg/raw/master/img/20210423203012.jpg" alt=""></p><p>当以列优先方式存储时，得出存储结构关系式为</p><script type="math/tex; mode=display">\operatorname{LOC}\left(a_{i, j}\right)=\operatorname{LOC}\left(a_{0,0}\right)+\left[j \times\left(h_{1}+1\right)+i\right] \times L</script><p>例：对于数组A<sub>2*3</sub>,按列优先方式在内存中存储形式：</p><p><img src="https://gitee.com/zxyss/blogimg/raw/master/img/20210423203116.jpg" alt=""></p><h3 id="3-4-3-矩阵的压缩存储"><a href="#3-4-3-矩阵的压缩存储" class="headerlink" title="3.4.3 矩阵的压缩存储"></a>3.4.3 矩阵的压缩存储</h3><p><strong>压缩存储</strong>: 指为多个值相同的元素只分配一个存储空间，对零元素不分配存储空间。其目的 是为了节省存储空间。</p><p> <strong>特殊矩阵</strong>: 指具有许多相同矩阵元素或零元素，并且这些相同矩阵元素或零元素的分布有一 定规律性的矩阵。</p><p>常见的特殊矩阵有对称矩阵、上（下）三角矩阵、对角矩阵等。 </p><p><strong>特殊矩阵的压缩存储方法</strong>：找出特殊矩阵中值相同的矩阵元素的分布规律，把那些呈现规律性分布的、值相同的多个矩阵元素压缩存储到一个存储空间中。</p><ol><li><strong>对称矩阵</strong></li></ol><p>若对一个 n 阶方阵 A [ 1 . . . m] 中的任意一个元素a<sub>i,j</sub> 都有 a<sub>i,j</sub> =a<sub>j,i</sub>, 则称其为对称矩阵。</p><p> 对于一个n阶方阵，其中的元素可以划分为 3 个部分， 即上三角区、主对角线和下三角区，如图 所示。</p><p><img src="https://gitee.com/zxyss/blogimg/raw/master/img/20210423203130.jpg" alt=""></p><p> 对于n阶对称矩阵，上三角区的所有元素和下三角区的对应元素相同，若仍采用二维数组存放，则会浪费几乎一半的空间，为此将对称矩阵 A [1…n ] [ 1…n] 存放 在一维数组 B [n (n+1) /2] 中，即元素a<sub>i,j</sub> 存放在 b<sub>k</sub>中。只存放下三角部分（含主对角）的元素。</p><p>因此，元素a<sub>i,j</sub>在数组B 中的下标 k=1+2+…+(i-1)+j-1=i(i-1) / 2+j-1数组下标从0开始)。因此，元素下标之间的对应关系如下:</p><script type="math/tex; mode=display">k=\left\{\begin{array}{ll}\frac{i(i-1)}{2}+j-1, & i \geq j(\text { 下三角区和主对角线元素 }) \\\frac{j(j-1)}{2}+i-1, & i<j\left(\text { 上三角区元素 } a_{i j}=a_{j i}\right)\end{array}\right.</script><ol><li><strong>三角矩阵</strong></li></ol><p>下三角矩阵 [见图 (a)] 中，上三角区的所有元素均为同一常量。</p><p>其存储思想与对称矩阵类似，不同之处在于存储完下三角区和主对角线上的元素之后，紧接着存储对角线上方的常量一 次，故可以将下三角矩阵 A[1…n] [1…n]压缩存储在B[n(n+1)/2+1]中。 元素下标之间的对应关系为</p><script type="math/tex; mode=display">k=\left\{\begin{array}{ll}\frac{i(i-1)}{2}+j-1, & i \geq j(\text { 下三角区和主对角线元素 }) \\\frac{n(n+1)}{2}, & i<j(\text { 上三角区元素 })\end{array}\right.</script><p>下三角矩阵在内存中的压缩存储形式：</p><p><img src="https://gitee.com/zxyss/blogimg/raw/master/img/20210423203148.jpg" alt=""></p><p><img src="https://gitee.com/zxyss/blogimg/raw/master/img/20210423203201.jpg" alt=""></p><p>上三角矩阵 [见图(b)] 中，下三角区的所有元 素均为同一常量。只需存储主对角线、上三角区上的元素和下三角区的常量一次，可将其压缩存储在 B [n (n+1) / 2+1] 中。</p><p>因此，元素a<sub>i,j</sub>在数组 $\mathrmB中的下标k=n+(n-1)+…+(n-i+2)+(j-i+1)-1=(i-1)(2 n-i+2) / 2+(j-i)。<br>因此，元素下标之间的对应关系如下:</p><script type="math/tex; mode=display">k=\left\{\begin{array}{ll}\frac{(i-1)(2 n-i+2)}{2}+(j-i), & i \leq j(\text { 上三角区和主对角线元素 }) \\\frac{n(n+1)}{2}, & i>j(\text { 下三角区元素 })\end{array}\right.</script><p>上三角矩阵在内存中的压缩存储形式：</p><p><img src="https://gitee.com/zxyss/blogimg/raw/master/img/20210423203223.jpg" alt=""></p><ol><li><strong>三角对称矩阵</strong></li></ol><p>对角矩阵也称带状矩阵。对于n阶方阵 A 中的任一元素a<sub>i,j</sub>, 当 |i-j|&gt;1 时，有 a<sub>i,j</sub>=0 （ 1 &lt;=i, j &lt;=n), 则称为三对角矩阵，如图所示。</p><p>在三对角矩阵中，所有非零元素都集中在以主对角线为中心的3条对角线的区域，其他区域的元素都为零。</p><p><img src="https://gitee.com/zxyss/blogimg/raw/master/img/20210423203357.jpg" alt=""></p><p>三对角矩阵A也可以采用压缩存储，将3条对角线上的元素按行优先方式存放在一维数组B中，且a<sub>1,1</sub>存放于B[0]中，其存储形式如图所示。</p><p><img src="https://gitee.com/zxyss/blogimg/raw/master/img/20210423203414.jpg" alt=""></p><p>由此可以计算矩阵A中3条对角线上的元素a<sub>i,j</sub>(1&lt;=i,j&lt;=n,|i-j|&lt;=1)在一维数组B中存放的下标为k=2i+j-3。</p><p> <img src="https://gitee.com/zxyss/blogimg/raw/master/img/20210423203432.jpg" alt=""></p><h3 id="3-4-4-稀疏矩阵"><a href="#3-4-4-稀疏矩阵" class="headerlink" title="3.4.4 稀疏矩阵"></a>3.4.4 稀疏矩阵</h3><p>矩阵中非零元素的个数t，相对矩阵元素的个数s来说非常少，即s&gt;&gt;t的矩阵称为<code>稀疏矩阵</code>。</p><p>例如，一个矩阵的阶为100x100，该矩阵中只有少于100个非零元素。<br>若采用常规的方法存储稀疏矩阵，则相当浪费存储空间，因此仅存储非零元素。但通常零元素的分布没有规律，所以仅存储非零元素的值是不够的，还要存储它所在的行和列。因此，将非零元素及其相应的行和列构成一个三元组（行标，列标，值），如图所示。然后再按照某种规律存储这些三元组。稀疏矩阵压缩存储后便失去了随机存取特性。</p><p><img src="https://gitee.com/zxyss/blogimg/raw/master/img/20210423203456.jpg" alt=""></p><p>稀疏矩阵的三元组既可以采用数组存储，也可以采用十字链法存储。</p>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一章-绪论</title>
    <link href="/2021/04/05/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%20%E7%BB%AA%E8%AE%BA/"/>
    <url>/2021/04/05/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%20%E7%BB%AA%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="考纲内容"><a href="#考纲内容" class="headerlink" title="考纲内容"></a>考纲内容</h1><p>（1）数据结构的相关概念和术语</p><p>（2）数据结构三要素：逻辑结构、物理结构和数据运算</p><p>（3）算法时间复杂度和空间复杂度的分析与计算</p><h1 id="知识框架"><a href="#知识框架" class="headerlink" title="知识框架"></a>知识框架</h1><p><img src="https://gitee.com/zxyss/blogimg/raw/master/img/20210423180619.jpg" alt=""></p><h2 id="1-1-数据结构的基本概念"><a href="#1-1-数据结构的基本概念" class="headerlink" title="1.1 数据结构的基本概念"></a>1.1 数据结构的基本概念</h2><h3 id="1-1-1-基本概念和术语"><a href="#1-1-1-基本概念和术语" class="headerlink" title="1.1.1 基本概念和术语"></a>1.1.1 基本概念和术语</h3><ol><li><strong>数据</strong></li></ol><p>数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号集合。</p><ol><li><strong>数据元素</strong></li></ol><p><code>数据元素</code>是数据的基本单位，通常作为一个整体进行考虑和处理。一个数据元素可由若干数据项组成，<code>数据项</code>是构成数据元素的不可分割的最小单位。</p><ol><li><strong>数据对象</strong></li></ol><p>数据对象是具有相同数据元素的集合，是数据的一个子集。</p><ol><li><strong>数据类型</strong></li></ol><p>数据类型是一个值的集合和定义在此集合上的一组操作的总称。</p><p>1）原子类型</p><p>其值不可再分的数据类型。</p><p>2）结构类型</p><p>其值可以再分解为若干成分（分量）的数据类型。</p><p>3）抽象数据类型</p><p>抽象数据组织及与之相关的操作。</p><ol><li><strong>数据结构</strong></li></ol><p><code>数据结构</code>是相互之间存在一种或多种特定关系的数据元素的集合。</p><p>数据元素之间的关系成为<code>结构（Structure）</code>。</p><p>数据结构包括三方面的内容：<code>逻辑结构</code>、<code>存储结构</code>和<code>数据的运算</code>。</p><p>算法的设计取决于选定的逻辑结构，算法的实现依赖于采用的存储结构。</p><h3 id="1-1-2-数据结构三要素"><a href="#1-1-2-数据结构三要素" class="headerlink" title="1.1.2 数据结构三要素"></a>1.1.2 数据结构三要素</h3><ol><li><strong>数据的逻辑结构</strong></li></ol><p>逻辑结构是指数据元素之间的逻辑关系，即从逻辑关系上描述数据。</p><p>与数据的存储无关，是独立于计算机的。</p><p>数据的逻辑结构分类线性结构和非线性结构。</p><p><img src="https://gitee.com/zxyss/blogimg/raw/master/img/20210423180634.jpg" alt=""></p><p><strong>集合</strong>：结构中的数据元素之间除“同属一个集合”外，别无其他关系。</p><p><strong>线性结构</strong>：结构中的数据元素之间只存在一对一的关系。</p><p><strong>树形结构</strong>：结构中的数据元素存在一对多的关系。</p><p><strong>图状结构</strong>：结构中的数据元素存在多对多的关系。</p><ol><li><strong>数据的存储结构</strong></li></ol><p>存储结构是指数据结构在计算机中的表示（又称映像），也称物理结构。</p><p>包括数据元素的表示和关系的表示。</p><p>数据的存储结构使用计算机语言实现的逻辑结构，依赖于计算机语言。</p><p><strong>数据结构的存储结构主要有：顺序存储、链式存储、缩阴存储和散列存储。</strong></p><p> 1）<strong>顺序存储</strong></p><p>把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现。</p><p><strong>优点</strong>：可以实现随机存取，每个元素占用最少的存储空间。</p><p><strong>缺点</strong>：只能使用相邻的一整块存储单元，因此可能产生较多的外部碎片。</p><p>2）<strong>链式存储</strong></p><p>不要求逻辑上相邻的元素在物理上也相邻，借助指示元素存储地址的指针来表示元素之间的逻辑关系。</p><p><strong>优点</strong>：不会出现碎片现象，能充分利用所有存储单元。</p><p><strong>缺点</strong>：每个元素因存储指针而占用额外的存储空间。，只能实现顺序存取。</p><p>3）<strong>索引存储</strong></p><p>在存储信息的同时，还建立附加的索引表。索引表中的每项成为<code>索引项</code>，索引的一般形式是（关键字，地址）。</p><p><strong>优点</strong>：检索速度快。</p><p><strong>缺点</strong>：附加的索引表额外占用存储空间。增加和删除数据时也要修改索引表，因而会花费较多的时间。</p><p>4）<strong>散列存储</strong></p><p>根据元素的关键字直接计算出该元素的存储地址，又称<code>哈希（Hash）存储</code>。</p><p><strong>优点</strong>：检索、增加和删除结点的操作都很快。</p><p><strong>缺点</strong>：散列函数不好，可能会出现元素存储单元的冲突，而解决冲突会增加时间和空间开销。</p><ol><li><strong>数据的运算</strong></li></ol><p>施加在数据上的运算包括运算的定义和实现。</p><p><code>运算的定义</code>是针对逻辑结构的，指出运算的功能。</p><p><code>运算的实现</code>是针对存储结构的，指出运算的具体操作步骤。</p><h2 id="1-2-算法和算法评价"><a href="#1-2-算法和算法评价" class="headerlink" title="1.2 算法和算法评价"></a>1.2 算法和算法评价</h2><h3 id="1-2-1-算法的基本概念"><a href="#1-2-1-算法的基本概念" class="headerlink" title="1.2.1 算法的基本概念"></a>1.2.1 算法的基本概念</h3><p><code>算法（Algorithm）</code>是对特定问题求解步骤的一种描述，它是指令的有序序列，其中的每条指令表示一个或多个操作。</p><p>一个算法具有5个重要的特性：</p><p>1）有穷性</p><p>一个算法必须在执行有穷步之后结束，且每一步都在有穷时间完成。</p><p>2）<strong>确定性</strong></p><p>算法中的每条置顶必须有确切的含义，对于相同的输入只能得出相同的输出。</p><p>3）<strong>可行性</strong></p><p>算法中描述的基本操作都可以通过已经实现的基本运算执行有限次数来实现。</p><p>4）<strong>输入</strong></p><p>一个算法有零个或多个输入，这些输入取自于某个特定的对象集合。</p><p>5）<strong>输出</strong></p><p>一个算法有一个或多个输出，这些输出是与输入有某种特定关系的量。</p><p>一个好的算法应该考虑达到以下目标：</p><p>1）<strong>正确性</strong></p><p>算法能够正确的解决求解问题。</p><p>2）<strong>可读性</strong></p><p>算法应该具有良好的可读性，以帮助人们理解。</p><p>3）<strong>健壮性</strong></p><p>输入非法数据时，算法能适当地做出反应或作出处理，而不会产生莫名其妙的输出结果。</p><p>4）<strong>效率与低存储量需求</strong></p><p>效率是指算法执行的时间。</p><p>存储量需求是指算法执行过程中所需要的最大存储空间。</p><p>两个都与问题的规模有关。</p><h3 id="1-2-2-算法效率的度量"><a href="#1-2-2-算法效率的度量" class="headerlink" title="1.2.2 算法效率的度量"></a>1.2.2 算法效率的度量</h3><p>算法效率的度量是通过<code>时间复杂度</code>和<code>空间复杂度</code>来描述的。</p><ol><li><strong>时间复杂度</strong></li></ol><p>一个语句的频度是指该语句在算法中被重复执行的次数。</p><p>算法中所有语句的频度之和T (n) ，它是该算法问题规模n的函数，时间复杂度主要分析T(n)的数量级。</p><p>算法中基本运算（最深层循环内的语句）的频度与T(n)同数量级，因此通常采用算法中基本运算的频度f(n)来分析算法的时间复杂度。</p><p><strong>算法时间复杂度记为：T(n)=O(f(n))</strong></p><p>O的含义是T(n)的数量级，严格的数学定义：</p><p>若T(n)和f(n)是定义在正整数集合上的两个函数，则存在正常数C和n<sub>0</sub>,使得n&gt;=n<sub>0</sub>时，都满足0&lt;=T(n)&lt;=Cf(n)</p><p><strong>最坏时间复杂度</strong>：在最坏情况下，算法的时间复杂度。</p><p><strong>最好时间复杂度</strong>：在最好情况下，算法的时间复杂度。</p><p><strong>平均时间复杂度</strong>：指所有可能输入实例在等概率出现的情况下，算法的期望运行时间。</p><p>一般总考虑最坏情况下的时间复杂度，以保证算法的运行时间不会比它更长。</p><p>分析一个程序的时间复杂度有两条规则：</p><p>1）<strong>加法规则</strong></p><p>T ( n ) = T <sub>1</sub>( n ) + T<sub>2</sub>( n ) = O(f ( n )) + O ( g ( n ) ) = O ( max ((f( n ) , g ( n ) ) )</p><p>2)<strong>乘法规则</strong></p><p>T ( n ) = T <sub>1</sub>( n ) <em> T<sub>2</sub>( n ) = O(f ( n ) )</em>O ( g ( n ) ) = O ( f( n ) * g ( n ) )</p><p>常见的渐近时间复杂度为：</p><p>O ( 1 ) &lt; O ( log<sub>2</sub>n ) &lt; O ( n ) &lt; O ( n  log<sub>2</sub>n ) &lt; O ( n<sup>2</sup>) &lt; O (n<sup>3</sup>) &lt; O ( <sub>2</sub>n ) &lt; O ( n! ) &lt; O ( n<sup>n</sup> )  </p><ol><li><strong>空间复杂度</strong></li></ol><p>算法的空间复杂度S(n)定义为该算法所耗费的存储空间，它是问题规模n的函数。记为：</p><p>S(n)=O(g(n))</p><p>若输入数据所占空间只取决于问题本身，和算法无关，则只需分析除输入和程序之外的额外空间。</p><p><code>算法原地工作</code>是指算法所需的辅助空间为常量，即O(1)。</p>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
