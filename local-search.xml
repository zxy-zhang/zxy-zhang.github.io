<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>第四章-串</title>
    <link href="/2021/04/23/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E4%B8%B2/"/>
    <url>/2021/04/23/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<p>【考纲内容】</p><p><strong>字符串模式匹配</strong></p><p>知识框架：</p><p><img src="https://gitee.com/zxyss/blogimg/raw/master/img/20210423203512.jpg" alt=""></p><h2 id="4-2-串的定义和实现"><a href="#4-2-串的定义和实现" class="headerlink" title="4.2 串的定义和实现"></a>4.2 串的定义和实现</h2><p><strong>字符串简称串，计算机上非数值处理的对象基本都是字符串数据。</strong></p><p>常见的信息检索系统 （如搜索引擎 )、文本编辑程序（如 Word 、问答系统、自然语言翻译系统等，都是以字符串数据作为处理对象的。</p><h3 id="4-1-1-串的定义"><a href="#4-1-1-串的定义" class="headerlink" title="4.1.1 串的定义"></a>4.1.1 串的定义</h3><p><code>串（string）</code>是由菱格或多个字符组成的有限序列。</p><p>一般记为：</p><p><strong>S=’a<sub>1</sub>a<sub>2</sub>···a<sub>n</sub>‘ (n&gt;=0)</strong></p><ul><li><p>S为串名，单引号括起来的字符序列是串的值。</p></li><li><p>a<sub>i</sub>可以是字母、数字或其他字符。</p></li><li><p>串中字符的个数n称为串的长度。</p></li><li><p>n=0的串称为空串（用 $\varnothing$ 表示）</p></li></ul><p>串中任意个连续的字符组成的子序列称为该串的<code>子串</code>，包含子串的串称为<code>主串</code>。</p><p>某个字符在串中的序号称为该字符在串中的位置。</p><p>子串在主串的位置以子串的第一个字符在主串中的位置来表示。</p><p>两个串的长度相等且每个对应位置的字符都相等时，称这两个串是相等的。</p><p>由一个或多个空格（空格为特殊字符）组成的串为空格串，长度为空格字符的个数。</p><p><strong>串的操作通常以子串作为操作对象，如查找、插入或删除一个子串等。</strong></p><h3 id="4-1-2-串的存储结构"><a href="#4-1-2-串的存储结构" class="headerlink" title="4.1.2 串的存储结构"></a>4.1.2 串的存储结构</h3><ol><li><strong>定长顺序存储表示</strong></li></ol><p>类似于线性表的顺序存储结构，用一组地址连续的存储单元存储串值的字符序列。</p><p>在串的定长顺序存储结构中，为每个串变量分配一个固定长度的存储区，即<code>定长数组</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXLEN 255</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>  <span class="hljs-keyword">char</span> ch[MAXLEN];<br>  <span class="hljs-keyword">int</span> length;<br>&#125;SString;<br></code></pre></td></tr></table></figure><p>串的实际长度只能小于等于MAXLEN，超过预定义长度的串值会被舍去，称为<code>截断</code>。</p><p>串有两种表示方法：</p><ol><li>用一个额外的变量len来存放串的长度。</li><li>在串值后面加一个不计入串长的结束标记字符“\0”，此时的串长为隐含值。</li></ol><p>在一些串的操作（如插入、联接等）中，任意串值序列的长度超过上界MAXLEN，约定用<code>截断</code>法处理，克服这种弊端，只能不限定串长的最大长度，即采用动态分配的方式。</p><ol><li><strong>堆分配存储表示</strong></li></ol><p>堆分配存储表示仍然是一组地址连续的存储单元存放串值的字符序列，但是他们的存储空间是在程序执行过程中动态分配得到的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>  <span class="hljs-keyword">char</span> *ch;<br>  <span class="hljs-keyword">int</span> length;<br>&#125;HString;<br></code></pre></td></tr></table></figure><p>c语言中有一个称为“堆”的自由存储区，并用malloc()和free()函数来完成动态存储管理。</p><p>利用malloc()为每个新产生的串分配一块实际串长所需的存储空间，若分配成功，则返回一个指向其起始地址的指针，作为串的<code>基地址</code>,这个串由ch指针来指示；</p><p>若分配失败，则返回null。已分配的空间可以用free()释放掉。</p><ol><li><strong>块链存储表示</strong></li></ol><p>由于串的特殊性（每个元素只有一个字符），在具体实现时，每个结点既可以存放一个字符，也可以存放多个字符。</p><p>每个结点称为<code>块</code>，整个链表称为<code>块链结构</code>。</p><p><img src="https://gitee.com/zxyss/blogimg/raw/master/img/20210425205246.png" alt="串值的链式存储方式"></p><p>（a）结点为大小为4的链表（即每个结点存放4个字符），最后一个结点占不满时通常用“#”补上。（b）为结点大小为1的链表。</p><h3 id="4-1-3-串的基本操作"><a href="#4-1-3-串的基本操作" class="headerlink" title="4.1.3 串的基本操作"></a>4.1.3 串的基本操作</h3><div class="table-container"><table><thead><tr><th>StrAssign(&amp;T,chars)</th><th>赋值操作，把串T赋值为chars</th></tr></thead><tbody><tr><td>StrCopy(&amp;T,S)</td><td>复制操作，由串S复制得到串T</td></tr><tr><td>StrEmpty(S)</td><td>判空操作，若S为空串，则返回True，否则返回False</td></tr><tr><td>StrCompare(S,T)</td><td>比较操作，若S&gt;T，则返回值&gt;0；若S=T，返回值=0；若S&lt;T，返回值《0</td></tr><tr><td>StrLength(S)</td><td>求串长，返回串S的元素个数</td></tr><tr><td>SubString(&amp;Sub,S,pos,len)</td><td>求子串，用Sub返回串S的第pos个字符起长度为len的子串</td></tr><tr><td>Concat(&amp;T,S1,S2)</td><td>串联接，用T返回由S1和S2联接而成的新串</td></tr><tr><td>Index(S,T)</td><td>定位操作，若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置，否则函数值为0</td></tr><tr><td>ClearString(&amp;S)</td><td>清空操作，将S清空为空串</td></tr><tr><td>DestroyString(&amp;S)</td><td>销毁串，将串S销毁</td></tr></tbody></table></div><p>利用判等、求串长和求子串等操作实现定位函数Index(S,T)</p><p>算法思想：在主串S中取第一个字符起，长度和串T相等的子串，与串T比较，若相等则求得函数值为i，否则i值增1，直至串S中不存在和串T相等的子串为止。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Index</span><span class="hljs-params">(String S,<span class="hljs-built_in">string</span> T)</span></span>&#123;<br>  <span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>,n=StrLength(S),m=Strlength(T);<br>  <span class="hljs-keyword">while</span>(i&lt;n-m+<span class="hljs-number">1</span>)&#123;<br>    SubString(sub,S,i,m);<br>    <span class="hljs-keyword">if</span>(StrCompare(sub,T)!=<span class="hljs-number">0</span>) ++i;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> i;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-2-串的模式匹配算法"><a href="#4-2-串的模式匹配算法" class="headerlink" title="4.2 串的模式匹配算法"></a>4.2 串的模式匹配算法</h2><h3 id="4-2-1-简单的模式匹配算法"><a href="#4-2-1-简单的模式匹配算法" class="headerlink" title="4.2.1 简单的模式匹配算法"></a>4.2.1 简单的模式匹配算法</h3><p><strong>串的模式匹配</strong>：子串的定位操作。</p><p>它求的是子串（常称模式串）在主串中的位置。</p><p>算法思想：简单的说，就是对主串的每个字符作为子串开头，与要匹配的字符串进行匹配。对主串做大循环，每个字符做T的长度的小循环，直到匹配成功或全部遍历完成为止。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//不依赖其他操作的暴力匹配算法</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Index</span><span class="hljs-params">(SString S,SString T)</span></span>&#123;<br>  <span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>,j=<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span>(i&lt;=S.length&amp;&amp;j&lt;=T.length)&#123;<br>    <span class="hljs-keyword">if</span>(S.ch[i]==T.ch[j])&#123;<br>      ++i,++j;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>      i=i-j+<span class="hljs-number">2</span>;j=<span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span>(j&gt;T.length)<br>      <span class="hljs-keyword">return</span> i-T.length;<br>    <span class="hljs-keyword">else</span><br>      retuen <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/zxyss/blogimg/raw/master/img/20210427204501.png" alt=""></p><p>最坏时间复杂度O((n-m+1)* m)</p><p><strong>最坏时间复杂度为O(mn),其中n和m为主串和模式串的长度。</strong></p><h3 id="4-2-2-改进的模式匹配算法-KMP算法"><a href="#4-2-2-改进的模式匹配算法-KMP算法" class="headerlink" title="4.2.2 改进的模式匹配算法-KMP算法"></a>4.2.2 改进的模式匹配算法-KMP算法</h3><ol><li><strong>字符串的前缀、后缀和部分匹配值</strong></li></ol><p>前缀：除最后一个字符以外，字符串的所有头部子串。</p><p>后缀：除第一个字符外，字符串的所有尾部子串。</p><p>部分匹配值：字符串的前缀和后缀的最长相等前后缀长度。</p><p><strong>移动位数=已匹配的字符数-对应的部分匹配值</strong></p><ol><li><strong>KMP算法原理</strong></li></ol><p><img src="https://gitee.com/zxyss/blogimg/raw/master/img/20210428204422.png" alt=""></p><p>按照朴素模式匹配算法，应该是23456流程。即主串中当i=2，3，4，5，6时，首字符与子串T的首字符均不等。</p><p>观察发现，“abcdex”首字母“a”与后面的串“bcdex”中任意一个字符都不相等，也就是说，子串T的首字符“a”不可能与S串的第2位到第5位字符相等，也就是说2345的判断都是多余的。</p><p>如果知道T 串中首字符“a”与 T中后面的字符均不相等。</p><p>而 T 串的第一位的“b”与 S串中第二位的“b”在图 (1)中已经判断是相等的，那么也就意味着，T 串中首 字符“a”与 S串中的第二位 “b” 是不需要判断也知道它们是不可能相等了，这样图(2)这一步判断是可以省略的。</p><p><img src="https://gitee.com/zxyss/blogimg/raw/master/img/20210428205312.png" alt=""></p><p>同样道理，在知道T 串中首字符“a”与 T 中后面的字符均不相等的前提下，T 串的“a”与 S 串后面的“c”、“d”、”e”也都可以在(1)之后就可以确定是不相等的，所以这个算法当中(2)(3)(4)没有必要，只保留(1)(6)即可。</p><p><img src="https://gitee.com/zxyss/blogimg/raw/master/img/20210428211847.png" alt=""></p><p><strong>假设T串后面也含有首字符“a”：</strong></p><p>S=“abcabcabc”，T=“abcabx”</p><p><img src="https://gitee.com/zxyss/blogimg/raw/master/img/20210428212226.png" alt=""></p><p>同理，2，3，4，5步骤多余。也就是说，对于在子串中有与首字符相等的字符，也是可以省略一部分不必要的判断步骤。</p><p><img src="https://gitee.com/zxyss/blogimg/raw/master/img/20210428212454.png" alt=""></p><p>如图，省略掉右图T串的前两位“a”与“b”同S串中的4、5位置字符匹配操作。</p><p>在朴素模式匹配算法中，主串的i值是不断回溯来完成的。KMP算法就是为了让没必要的回溯不发生。</p><p>i值不回溯，就是不可以变小，考虑的变化就是j值了。T串的首字符与自身后面字符的比较，发现有相等的字符，j值的变化就会不相同。</p><p>也就是说，j值的变化与主串没什么关系，关键取决于T串的结构中是否有重复的问题。</p><p>T=“abcdex”当中没有重复的字符，j由6变成了1。</p><p>T=“abcabx”，前缀“ab”与最后“x”之前串的后缀“ab”是相等的。所以j由6变成了3.</p><p>得出规律：<strong>j值的多少取决于当前字符之前的串的前后缀的相似度。</strong></p><p>把T串各个位置的j值的变化定义为一个next数组，那么next的长度就是T串的长度。得到以下定义函数：</p><script type="math/tex; mode=display">\text { next }[j]=\left\{\begin{array}{lc}0,j=1 \\\max \left\{k \mid 1<k<j \text { 且 }^{\prime} p_{1} \cdots p_{k-1}{^\prime}={ }^{\prime} p_{j-k+1} \cdots p_{j-1}{ }^{\prime}\right\}, \text { 当此集合不空时 } \\1,\text { 其他情况 }\end{array}\right.</script><ol><li><strong>next数组值推导</strong></li></ol><p>(1) T=”abcdex”</p><div class="table-container"><table><thead><tr><th>j</th><th>123456</th></tr></thead><tbody><tr><td>模式串T</td><td>abcdex</td></tr><tr><td>next[j]</td><td>11111</td></tr></tbody></table></div><p>1) 当 $\mathrm{j}=1$ 时, $\operatorname{next}[1]=0$;<br>2) 当 $\mathrm{j}=2$ 时， $\mathrm{j}$ 由 1 到 $\mathrm{j}-1$ 就只有字符“a”，属于其他情况 next[2]=1;<br>3) 当 $\mathrm{j}=3$ 时, $\mathrm{j}$ 由 1 到 $\mathrm{j}-1$ 串是“ab”，显然“a”与“b”不相等，属其他情 况， $\operatorname{next}[3]=1$;<br>4) 以后同理，所以最终此 T 串的 next[j]为 011111。</p><p>(2)T=”abcabx”</p><div class="table-container"><table><thead><tr><th>j</th><th>123456</th></tr></thead><tbody><tr><td>模式串T</td><td>abcabx</td></tr><tr><td>next[j]</td><td>011123</td></tr></tbody></table></div><p>1) 当 $\mathrm{j}=1$ 时, next $[1]=0$;<br>2) 当 $\mathrm{j}=2$ 时，同上例说明, $\mathrm{next}[2]=1$;<br>3) 当 $\mathrm{j}=3$ 时，同上, $\operatorname{next}[3]=1$;<br>4) 当 $\mathrm{j}=4$ 时，同上, $\mathrm{next}[4]=1$;<br>5) 当 $\mathrm{j}=5$ 时，此时 $\mathrm{j}$ 由 1 到 $\mathrm{j}-1$ 的串是“ $\underline{\mathrm{abc} a ”}$, 前缀字符“a”与后缀字符 “a”相等（前缀用下划线表示，后缀用斜体表示），因此可推算出 $\mathrm{k}$ 值为 2 (由 ‘ $\mathrm{p}<em>{1} \cdots \mathrm{p}</em>{\mathrm{k}-1}^{\prime}={ }^{\prime} \mathrm{p}<em>{\mathrm{j}-\mathrm{k}+1} \cdots \mathrm{p}</em>{\mathrm{j}-1}^{\prime}$, 得到 $\left.\mathrm{p}<em>{1}=\mathrm{p}</em>{4}\right)$ 因此 $\operatorname{next}[5]=2$;<br>相等，所以 $\mathrm{next}[6]=3$ 。</p><p><strong>可以根据经验得到如果前后缀一个字符相等，k值是2，两个字符值是3，n个相等k值就是n+1。</strong></p><p>（3） T=“ababaaaba”</p><div class="table-container"><table><thead><tr><th>j</th><th>123456789</th></tr></thead><tbody><tr><td>模式串T</td><td>ababaaaba</td></tr><tr><td>next[j]</td><td>011234223</td></tr></tbody></table></div><p>1) 当 $\mathrm{j}=1$ 时, next $[1]=0$;<br>2) 当 $\mathrm{j}=2$ 时，同上 $\mathrm{next}[2]=1$;<br>3) 当 $\mathrm{j}=3$ 时，同上 $\mathrm{next}[3]=1$;<br>等, $\operatorname{next}[4]=2$;<br>5) 当 $\mathrm{j}=5$ 时，j由 1 到 $\mathrm{j}-1$ 的串是“ $\underline{\text { ab } a b ”,}$ 由于前缀字符“ab”与后缀“ab”<br>相等，所以 next[5]=3;<br>6) 当 $\mathrm{j}=6$ 时, $\mathrm{j}$ 由 1 到 $\mathrm{j}-1$ 的串是“ababa”, 由于前缀字符“aba” 与后缀 “aba” 相等，所以 $\mathrm{next}[6]=4$;<br>“aa” 并不相等，只有“a”相等，所以 $n e x t[7]=2$;<br>8) 当 $\mathrm{j}=8$ 时，j 由 1 到 $\mathrm{j}-1$ 的串是“ ąbabaaa”，只有“a”相等，所以 next $[8]=2$;<br>9) 当 $\mathrm{j}=9$ 时， $\mathrm{j}$ 由 1 到 $\mathrm{j}-1$ 的串是“ ababaaab”, 由于前缀字符“ab”与后缀 “ab”相等，所以 next[9]=3。</p><p>(4) T=”aaaaaaaab”</p><div class="table-container"><table><thead><tr><th>j</th><th>123456789</th></tr></thead><tbody><tr><td>模式串T</td><td>aaaaaaaab</td></tr><tr><td>next[j]</td><td>012345678</td></tr></tbody></table></div><p>1) 当 $\mathrm{j}=1$ 时, $\mathrm{next}[1]=0$;<br>2) 当 $\mathrm{j}=2$ 时，同上 $\mathrm{next}[2]=1$;<br>3) 当 $\mathrm{j}=3$ 时, $\mathrm{j}$ 由 1 到 $\mathrm{j}-1$ 的串是“ $\underline{\mathrm{a}} a$ ”, 前缀字符“a”与后缀字符“a”相等, $\operatorname{next}[3]=2$;<br>4) 当 $\mathrm{j}=4$ 时， $\mathrm{j}$ 由 1 到 $\mathrm{j}-1$ 的串是“ $\underline{\text { aaa }}$, 由于前缀字符 与后缀“aa” 相<br>等, 所以 $\operatorname{next}[4]=3$;</p><p>5) $\ldots \ldots$<br>缀 “aaaaaa” 相等 , 所以 $\operatorname{next}[9]=8$ 。</p><ol><li><strong>KMP模式匹配算法实现</strong></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get_next</span><span class="hljs-params">(String T,<span class="hljs-keyword">int</span> next[])</span></span>&#123;<br>  <span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>,j=<span class="hljs-number">0</span>;<br>  next[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span>(i&lt;T.length)&#123;<br>    <span class="hljs-keyword">if</span>(j==<span class="hljs-number">0</span>||T.ch[i]==T.ch[j])&#123;<span class="hljs-comment">/* T[i]表示后缀单个字符，T[j]表示前缀单个字符 */</span><br>      ++i,++j;<br>      next[i]=j;   <span class="hljs-comment">/* 若pi=pj,则next[j+1]=next[j]+1*/</span><br>    &#125;<br>    <span class="hljs-keyword">else</span><br>      j=next[j];   <span class="hljs-comment">/*字符不相同，j值回溯，循环继续 */</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>计算当前要匹配的串的T的next数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*返回子串T在主串S中第pos个字符之后的位置，若不存在，则函数返回值为0 */</span><br><span class="hljs-comment">/*T非空，1&lt;=pos&lt;StrLength(S) */</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">INdex_KMP</span><span class="hljs-params">(String S,String T,<span class="hljs-keyword">int</span> pos)</span></span>&#123;<br>  <span class="hljs-keyword">int</span> i=pos;  <span class="hljs-comment">//i用于主串S当前位置下标值，若pos不为1，则从pos位置开始匹配</span><br>  <span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;    <span class="hljs-comment">//j用于子串T中当前位置下标值</span><br>  <span class="hljs-keyword">int</span> next[<span class="hljs-number">255</span>];<br>  get_next(T,next);<br>  <span class="hljs-keyword">while</span>(i&lt;=S[<span class="hljs-number">0</span>]&amp;&amp;j&lt;=T[<span class="hljs-number">0</span>])&#123;<br>    <span class="hljs-keyword">if</span>(j==<span class="hljs-number">0</span>||S[i]=T[j])&#123;<br>      ++i;<br>      ++j;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>      j=next[j];<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span>(j&gt;T[<span class="hljs-number">0</span>])<br>    <span class="hljs-keyword">return</span> i-T[<span class="hljs-number">0</span>];<br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>朴素匹配算法时间复杂度为O（mn），KMP算法时间复杂度为O（m+n）</p><p>一般情况下，朴素模式匹配实际执行时间近似O（m+n）</p><p>KMP算法仅在主串与子串有很多“部分匹配”时才显得比普通算法快的多，主要优点是主串不回溯。</p><h3 id="4-2-3-KMP算法进一步优化"><a href="#4-2-3-KMP算法进一步优化" class="headerlink" title="4.2.3 KMP算法进一步优化"></a>4.2.3 KMP算法进一步优化</h3><p>KMP 还是有缺陷的。比如，如果我们的主串 S=”aaabcde”，子串$\mathrm{T}=$ “aaaaax”, 其 next 数组值分别为 012345。</p><p>在开始时，当i=5,j=5时，“b”与“a”不等，如图(1)，因此 j=next[5]=4，如图中的(2)，此时“b”与第 4 位置的“ a”依然不等，j=next[4]=3，如图中的(3)，后依次是(4)(5), 直到j=next[1]时，根据算法，此时 i++、j++, 得到 i=6、j=1，如图中的(6)。</p><p><img src="https://gitee.com/zxyss/blogimg/raw/master/img/20210429165557.png" alt=""></p><p>2345步骤，都是多余的判断，T串的第2，3，4，5位置的字符都与首位的“a”相等，可以用首位next[1]的值取代与他相等的字符后续的next[j]的值。</p><p>这个取代的数组称为：nextval，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//求模式串T的nexy函数修正值并存入nextval</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get_nextval</span><span class="hljs-params">(String T,<span class="hljs-keyword">int</span> *nextval)</span></span>&#123;<br>  <span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>,j=<span class="hljs-number">0</span>;<br>  nextval[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span>(i&lt;T.length)&#123;<br>    <span class="hljs-keyword">if</span>(j==<span class="hljs-number">0</span>||T.ch[i]==T.ch[j])&#123;<br>      ++i,++j;<br>      <span class="hljs-keyword">if</span>(T.ch[i]!=T.ch[j])  <span class="hljs-comment">//当前字符与前缀字符不同</span><br>        nextval[i]=j;       <span class="hljs-comment">//则当前的j为nextval在i的位置的值</span><br>      <span class="hljs-keyword">else</span><br>        nextval[i]=nextval[j]; <span class="hljs-comment">//如果与前缀字符相同，则将前缀字符的nextval//值赋值给nextval在i位置的值</span><br>    &#125;<br>    <span class="hljs-keyword">else</span><br>      j=nextval[j];   <span class="hljs-comment">//字符不相同，j值回溯 </span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际匹配算法，只需要将“get_next(T,next)；”改成“get_nextval(T,next);”即可。</p><p><strong>nextval数值推导</strong></p><ol><li>T=”ababaaaba”</li></ol><div class="table-container"><table><thead><tr><th>j</th><th>123456789</th></tr></thead><tbody><tr><td>模式串T</td><td>ababaaaba</td></tr><tr><td>next[j]</td><td>011234223</td></tr><tr><td>nextval[j]</td><td>010104201</td></tr></tbody></table></div><p>1) 当j=1时, nextval[1]=0;<br>2) 当j=2 时，因第二位字符“b”的 next 值是 1 , 而第一位就是 “a”, 它们不相等，所以 nextval[2]=next[2]=1，维持原值。<br>3) 当j=3 时，因为第三位字符“a”的 $\mathrm{next}$ 值为 1 , 所以与第一位的“a” 比较得<br>知它们相等，所以 nextval[3]=nextval[1]=0; 如图所示。</p><p><img src="https://gitee.com/zxyss/blogimg/raw/master/img/20210429195234.png" style="zoom:50%;" /></p><p>4) 当j=4时，第四位的字符“b”next 值为 2, 所以与第二位的 “b”相比较得到<br>结果是相等，因此 nextval[4]=nextval[2]=1; 如图所示。</p><p><img src="https://gitee.com/zxyss/blogimg/raw/master/img/20210429195450.png" style="zoom:50%;" /></p><p>5) 当j=5 时，next 值为 3, 第五个字符“a” 与第三个字符“a”相等，因此nextval[5]=nextval[3]=0;<br>6) 当j=6 时, next 值为 4, 第六个字符“a”与第四个字符“b”不相等，因此nextval [6]=4;<br>7) 当j=7 时，next 值为 2, 第七个字符“a”与第二个字符“b”不相等，因此 nextval[7]=2;<br>8) 当j=8 时, next 值为 2，第八个字符“b” 与第二个字符“b”相等，因此 nextval[8]=nextval[2]=1;<br>9) 当 j=9时, next 值为 3, 第九个字符“a” 与第三个字符 “a”相等，因此 nextval [9]=nextval[3]=1。</p><ol><li>T=”aaaaaaaab”</li></ol><div class="table-container"><table><thead><tr><th>j</th><th>123456789</th></tr></thead><tbody><tr><td>模式串T</td><td>aaaaaaaab</td></tr><tr><td>next[j]</td><td>012345678</td></tr><tr><td>nextval[j]</td><td>000000008</td></tr></tbody></table></div><p>1) 当 j=1时, nextval[1]=0;<br>2) 当 j=2 时, next 值为 1 , 第二个字符与第一个字符相等，所以 nextval[2]=nextval[1]=0;<br>3) 同样的道理，其后都为 0….;<br>4) 当j=9 时，next 值为 8, 第九个字符“b”与第八个字符“a”不相等，所以nextval[9]=8.</p><p>总结：改进过的KMP算法，是在计算出next值的同时，如果a字符与它next值指向的b字符相等，则该a位的nextval就指向b位的nextval值，如果不等，则该a位的nextval值就是它自己a位的next值。</p>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
